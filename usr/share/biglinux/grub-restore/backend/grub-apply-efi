#!/bin/bash
##################################
#  BigLinux GRUB Restore - EFI Apply Script
#  Author: Bruno Goncalves (www.biglinux.com.br) 
#  Date: 2024
#  
#  Description: Apply GRUB restore for EFI systems
#  Adapted for GTK4 frontend
#  
# Licensed by GPL V2 or greater
##################################

# Translation setup
export TEXTDOMAINDIR="/usr/share/locale"
export TEXTDOMAIN=grub-restore

# Function to log messages with timestamps
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" >&2
}

# Function to show progress
show_progress() {
    echo "PROGRESS: $1"
}

# Function to handle errors
handle_error() {
    local error_msg="$1"
    local exit_code="${2:-1}"
    log_message "ERROR: $error_msg"
    echo "ERROR: $error_msg" >&2
    exit $exit_code
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Validate required commands
validate_commands() {
    local required_commands=("manjaro-chroot" "mount" "umount")
    
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "$cmd"; then
            handle_error "Required command not found: $cmd"
        fi
    done
}

# Function to safely mount partition
safe_mount() {
    local partition="$1"
    local mount_point="$2"
    local mount_options="$3"
    
    # Unmount if already mounted
    umount -l "$mount_point" 2>/dev/null || true
    
    # Create mount point if it doesn't exist
    mkdir -p "$mount_point"
    
    # Mount with options
    if [ -n "$mount_options" ]; then
        if mount "$partition" -o "$mount_options" "$mount_point"; then
            log_message "Successfully mounted $partition to $mount_point with options: $mount_options"
            return 0
        else
            handle_error "Failed to mount $partition to $mount_point with options: $mount_options"
        fi
    else
        if mount "$partition" "$mount_point"; then
            log_message "Successfully mounted $partition to $mount_point"
            return 0
        else
            handle_error "Failed to mount $partition to $mount_point"
        fi
    fi
}

# Function to safely unmount
safe_unmount() {
    local mount_point="$1"
    local description="$2"
    
    log_message "Unmounting $description: $mount_point"
    if umount "$mount_point" 2>/dev/null; then
        log_message "Successfully unmounted $mount_point"
    else
        log_message "Warning: Could not unmount $mount_point (may not be mounted)"
    fi
}

# Function to execute chroot command with error handling
execute_chroot() {
    local command="$1"
    local description="$2"
    
    log_message "Executing in chroot: $command"
    show_progress "$description"
    
    if manjaro-chroot /mnt $command; then
        log_message "Successfully executed: $command"
        return 0
    else
        local exit_code=$?
        log_message "Failed to execute: $command (exit code: $exit_code)"
        return $exit_code
    fi
}

# Main script starts here
log_message "Starting EFI GRUB restore script"

# Validate environment
validate_commands

# Read configuration from temporary files
if [ ! -f /tmp/efi-selected ]; then
    handle_error "EFI partition selection file not found"
fi

if [ ! -f /tmp/os-prober-selected ]; then
    handle_error "OS selection file not found"
fi

if [ ! -f /tmp/grub-restore-apply-mode ]; then
    handle_error "Restore mode file not found"
fi

# Read variables
EFI_PARTITION="$(cat /tmp/efi-selected)"
SELECTED_PARTITION="$(awk -F: '{ print $1}' /tmp/os-prober-selected)"
SELECTED_OS="$(awk -F: '{ print $2 " - " $3 }' /tmp/os-prober-selected)"
PARTITION_FORMAT="$(awk -F: '{ print $5 }' /tmp/os-prober-selected)"
UUID_PARTITION="$(awk -F: '{ print $6 }' /tmp/os-prober-selected | sed 's|UUID=||g')"
RESTORE_MODE="$(cat /tmp/grub-restore-apply-mode)"

# Validate variables
if [ -z "$EFI_PARTITION" ]; then
    handle_error "EFI partition not specified"
fi

if [ -z "$SELECTED_PARTITION" ]; then
    handle_error "Target partition not specified"
fi

if [ -z "$RESTORE_MODE" ]; then
    handle_error "Restore mode not specified"
fi

# Log configuration
log_message "Configuration:"
log_message "  EFI Partition: $EFI_PARTITION"
log_message "  Target Partition: $SELECTED_PARTITION"
log_message "  Selected OS: $SELECTED_OS"
log_message "  Partition Format: $PARTITION_FORMAT"
log_message "  UUID: $UUID_PARTITION"
log_message "  Restore Mode: $RESTORE_MODE"

# Validate partitions exist
if [ ! -b "$EFI_PARTITION" ]; then
    handle_error "EFI partition does not exist: $EFI_PARTITION"
fi

if [ ! -b "$SELECTED_PARTITION" ]; then
    handle_error "Target partition does not exist: $SELECTED_PARTITION"
fi

# Unmount existing mounts
show_progress "Preparing mount points..."
safe_unmount "$SELECTED_PARTITION" "target partition"
safe_unmount "/mnt" "mount directory"

# Mount the target partition
show_progress "Mounting target partition..."
if [ "$PARTITION_FORMAT" = "btrfs" ]; then
    safe_mount "$SELECTED_PARTITION" "/mnt" "subvol=@"
else
    safe_mount "$SELECTED_PARTITION" "/mnt"
fi

# Create and mount EFI directory
show_progress "Mounting EFI partition..."
mkdir -p /mnt/boot/efi
safe_mount "$EFI_PARTITION" "/mnt/boot/efi"

# Execute restore based on mode
case "$RESTORE_MODE" in
    "1")
        log_message "Executing Simple Restore (Mode 1)"
        show_progress "Installing GRUB to EFI partition..."
        
        if ! execute_chroot "grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=biglinux --recheck" "Installing GRUB"; then
            handle_error "GRUB installation failed"
        fi
        ;;
        
    "2")
        log_message "Executing Intermediate Restore (Mode 2)"
        
        show_progress "Removing package lock..."
        execute_chroot "rm -f /var/lib/pacman/db.lck" "Removing package lock"
        
        show_progress "Updating GRUB package..."
        if ! execute_chroot "pacman --noconfirm -Sy grub" "Updating GRUB package"; then
            log_message "Warning: GRUB package update failed, continuing..."
        fi
        
        show_progress "Installing GRUB..."
        if ! execute_chroot "grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=biglinux --recheck" "Installing GRUB"; then
            handle_error "GRUB installation failed"
        fi
        
        show_progress "Regenerating initramfs..."
        if ! execute_chroot "mkinitcpio -P" "Regenerating initramfs"; then
            log_message "Warning: initramfs regeneration failed, continuing..."
        fi
        
        show_progress "Generating GRUB configuration..."
        if ! execute_chroot "grub-mkconfig -o /boot/grub/grub.cfg" "Generating GRUB configuration"; then
            handle_error "GRUB configuration generation failed"
        fi
        ;;
        
    "3")
        log_message "Executing Complete Restore (Mode 3)"
        
        show_progress "Removing package lock..."
        execute_chroot "rm -f /var/lib/pacman/db.lck" "Removing package lock"
        
        show_progress "Updating package database..."
        if ! execute_chroot "pamac update --force-refresh --no-confirm" "Updating package database"; then
            log_message "Warning: Package database update failed, trying alternative method..."
            execute_chroot "pacman --noconfirm -Sy" "Updating package database (alternative)"
        fi
        
        show_progress "Installing/updating core packages..."
        if ! execute_chroot "pamac install linux grub --no-confirm" "Installing core packages"; then
            log_message "Warning: pamac install failed, trying pacman..."
            execute_chroot "pacman --noconfirm -S grub" "Installing GRUB via pacman"
            execute_chroot "pacman --noconfirm -S linux" "Installing Linux kernel via pacman"
        fi
        
        show_progress "Performing full system update..."
        execute_chroot "pacman --noconfirm -Syyuu grub" "Updating GRUB"
        execute_chroot "pacman --noconfirm -Syyuu linux" "Updating Linux kernel"
        
        show_progress "Installing GRUB..."
        if ! execute_chroot "grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=biglinux --recheck" "Installing GRUB"; then
            handle_error "GRUB installation failed"
        fi
        
        show_progress "Regenerating initramfs..."
        if ! execute_chroot "mkinitcpio -P" "Regenerating initramfs"; then
            log_message "Warning: initramfs regeneration failed, continuing..."
        fi
        
        show_progress "Generating GRUB configuration..."
        if ! execute_chroot "grub-mkconfig -o /boot/grub/grub.cfg" "Generating GRUB configuration"; then
            handle_error "GRUB configuration generation failed"
        fi
        ;;
        
   "4")
        log_message "Opening Interactive Terminal (Mode 4)"
        show_progress "Starting interactive shell..."
        execute_chroot "bash" "Interactive shell"
        ;;
        
    "5")
        log_message "Opening Control Center (Mode 5)"
        show_progress "Starting control center..."
        
        # Detect session type
        SESSION_TYPE="${XDG_SESSION_TYPE:-x11}"
        log_message "Session type: $SESSION_TYPE"
        
        if [ "$SESSION_TYPE" = "wayland" ]; then
            log_message "Running in Wayland session"
            
            # Mount the user's runtime directory to make sockets available in chroot
            mount --bind /run/user/1000 /mnt/run/user/1000 2>/dev/null || true
            
            # For XWayland fallback, we might need X11 authority.
            # Copy it if it exists, but don't fail if it doesn't.
            CHROOT_XAUTH_FILE="/tmp/.docker.xauth"
            if [ -n "$XAUTHORITY" ] && [ -f "$XAUTHORITY" ]; then
                cp "$XAUTHORITY" "/mnt$CHROOT_XAUTH_FILE"
            fi

            # Execute with all potentially necessary environment variables for Wayland and XWayland fallback
            execute_chroot "env DISPLAY=$DISPLAY WAYLAND_DISPLAY=$WAYLAND_DISPLAY XDG_RUNTIME_DIR=/run/user/1000 DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS XAUTHORITY=$CHROOT_XAUTH_FILE bigcontrolcenter" "Control center"
            
            # Cleanup
            rm "/mnt$CHROOT_XAUTH_FILE" 2>/dev/null || true
            umount /mnt/run/user/1000 2>/dev/null || true
            
        else
            log_message "Running in X11 session"
            
            # For X11, we need both Xauthority and D-Bus access for modern GTK apps
            if [ -n "$XAUTHORITY" ] && [ -f "$XAUTHORITY" ]; then
                # 1. Mount the user runtime dir to make D-Bus socket available
                mount --bind /run/user/1000 /mnt/run/user/1000 2>/dev/null || true

                # 2. Copy the Xauthority file into the chroot
                CHROOT_XAUTH_FILE="/tmp/.docker.xauth"
                cp "$XAUTHORITY" "/mnt$CHROOT_XAUTH_FILE"
                
                # 3. Execute with all necessary environment variables
                execute_chroot "env DISPLAY=$DISPLAY XAUTHORITY=$CHROOT_XAUTH_FILE DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS bigcontrolcenter" "Control center"
                
                # 4. Cleanup
                rm "/mnt$CHROOT_XAUTH_FILE" 2>/dev/null || true
                umount /mnt/run/user/1000 2>/dev/null || true
            else
                log_message "Warning: XAUTHORITY file not found, graphical app may fail."
                # Fallback to old method if XAUTHORITY is not set
                xhost + 2>/dev/null || true
                execute_chroot "env DISPLAY=$DISPLAY pamac-manager" "Package manager"
                xhost - 2>/dev/null || true
            fi
        fi
        ;;

    "6")
        log_message "Opening Package Manager (Mode 6)"
        show_progress "Removing package lock..."
        execute_chroot "rm -f /var/lib/pacman/db.lck" "Removing package lock"
        
        show_progress "Starting package manager..."
        
        # Detect session type
        SESSION_TYPE="${XDG_SESSION_TYPE:-x11}"
        log_message "Session type: $SESSION_TYPE"
        
        if [ "$SESSION_TYPE" = "wayland" ]; then
            log_message "Running in Wayland session"
            
            # Mount the user's runtime directory to make sockets available in chroot
            mount --bind /run/user/1000 /mnt/run/user/1000 2>/dev/null || true
            
            # For XWayland fallback, we might need X11 authority.
            # Copy it if it exists, but don't fail if it doesn't.
            CHROOT_XAUTH_FILE="/tmp/.docker.xauth"
            if [ -n "$XAUTHORITY" ] && [ -f "$XAUTHORITY" ]; then
                cp "$XAUTHORITY" "/mnt$CHROOT_XAUTH_FILE"
            fi

            # Execute with all potentially necessary environment variables for Wayland and XWayland fallback
            execute_chroot "env DISPLAY=$DISPLAY WAYLAND_DISPLAY=$WAYLAND_DISPLAY XDG_RUNTIME_DIR=/run/user/1000 DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS XAUTHORITY=$CHROOT_XAUTH_FILE pamac-manager" "Package manager"
            
            # Cleanup
            rm "/mnt$CHROOT_XAUTH_FILE" 2>/dev/null || true
            umount /mnt/run/user/1000 2>/dev/null || true
            
        else
            log_message "Running in X11 session"
            
            # For X11, we need both Xauthority and D-Bus access for modern GTK apps
            if [ -n "$XAUTHORITY" ] && [ -f "$XAUTHORITY" ]; then
                # 1. Mount the user runtime dir to make D-Bus socket available
                mount --bind /run/user/1000 /mnt/run/user/1000 2>/dev/null || true

                # 2. Copy the Xauthority file into the chroot
                CHROOT_XAUTH_FILE="/tmp/.docker.xauth"
                cp "$XAUTHORITY" "/mnt$CHROOT_XAUTH_FILE"
                
                # 3. Execute with all necessary environment variables
                execute_chroot "env DISPLAY=$DISPLAY XAUTHORITY=$CHROOT_XAUTH_FILE DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS pamac-manager" "Package manager"
                
                # 4. Cleanup
                rm "/mnt$CHROOT_XAUTH_FILE" 2>/dev/null || true
                umount /mnt/run/user/1000 2>/dev/null || true
            else
                log_message "Warning: XAUTHORITY file not found, graphical app may fail."
                # Fallback to old method if XAUTHORITY is not set
                xhost + 2>/dev/null || true
                execute_chroot "env DISPLAY=$DISPLAY pamac-manager" "Package manager"
                xhost - 2>/dev/null || true
            fi
        fi
        ;;
        
    *)
        handle_error "Invalid restore mode: $RESTORE_MODE"
        ;;
esac

# Cleanup and unmount
show_progress "Syncing filesystems..."
sync
sleep 2

show_progress "Unmounting filesystems..."
safe_unmount "/mnt/boot/efi" "EFI partition"
sleep 1
safe_unmount "/mnt" "target partition"
sleep 1

log_message "EFI GRUB restore completed successfully"
show_progress "Restore operation completed!"

exit 0